// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import "./GSAT.sol";
import "./interfaces/IFactoryERC721.sol";
import "./interfaces/IProxyRegistry.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract GSATFactory is Context, Ownable, IFactoryERC721 {
    using Strings for uint256;

    uint256 private constant NB_OF_TOKENS = 3;

    GSAT public token;
    IProxyRegistry public registry;

    constructor(GSAT _token, IProxyRegistry _registry) {
        token = _token;
        registry = _registry;
    }

    function name() public view override returns (string memory) {
        return token.name();
    }

    function symbol() public view override returns (string memory) {
        return token.symbol();
    }

    function numOptions() public view override returns (uint256) {
        return token.cap();
    }

    function supportsFactoryInterface() public pure override returns (bool) {
        return true;
    }

    function canMint(uint256 _optionId) public view override returns (bool) {
        return token.canMint(_optionId);
    }

    function tokenURI(uint256 _optionId) public view override returns (string memory) {
        require(_optionId >= 1 && _optionId <= token.cap(), "GSATFactory: URI query for nonexistent token");

        return string(abi.encodePacked(token.baseTokenURI(), _optionId.toString()));
    }

    function mint(uint256 _optionId, address _toAddress) public override {
        address sender = _msgSender();
        address owner = owner();

        require(sender == registry.proxies(owner) || sender == owner, "GSATFactory: must be owner's proxy or owner to mint");
        require(canMint(_optionId), "GSATFactory: unavailable token");

        token.mint(_toAddress, _optionId);
    }

    /** hacks required for the contract to work on OpenSea */

    function transferFrom(
        address _from,
        address _to,
        uint256 _tokenId
    ) public {
        mint(_tokenId, _to);
    }

    function isApprovedForAll(address _owner, address _operator) public view returns (bool) {
        address owner = owner();

        if (_owner == owner && _operator == _owner) {
            return true;
        }

        if (_owner == owner && _operator == registry.proxies(_owner)) {
            return true;
        }

        return false;
    }

    function ownerOf(uint256 _tokenId) public view returns (address) {
        try token.ownerOf(_tokenId) returns (address owner) {
            return owner;
        } catch {
            return owner();
        }
    }
}
